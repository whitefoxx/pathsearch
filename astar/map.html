<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <title>Canvas tutorial</title>
    <style>
      body {
        margin: 0 !important;
        padding: 0 !important;
      }
    </style>
    <script>
      class Node {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.parent = undefined;
          this.pathD = Infinity; // 起点到这个点的实际距离
          this.heuristicD = Infinity; // 这个点到终点的启发函数计算出来的估计距离
          this.key = `${this.x},${this.y}`;
        }

        reset() {
          this.parent = undefined;
          this.pathD = Infinity;
          this.heuristicD = Infinity;
        }

        isAt(x, y) {
          return this.x == x && this.y == y;
        }

        equal(node) {
          return this.x == node.x && this.y == node.y;
        }

        neighborCoords() {
          const coords = new Array();
          coords.push([this.x - 1, this.y - 1]);
          coords.push([this.x, this.y - 1]);
          coords.push([this.x + 1, this.y - 1]);
          coords.push([this.x - 1, this.y]);
          coords.push([this.x + 1, this.y]);
          coords.push([this.x - 1, this.y + 1]);
          coords.push([this.x, this.y + 1]);
          coords.push([this.x + 1, this.y + 1]);
          return coords;
        }
      }

      class NodeSet {
        constructor() {
          this.map = new Map();
        }

        clear() {
          this.map.clear();
        }

        print() {
          this.map.forEach((n, k) => {
            // console.log("node:", n.x, n.y);
          });
        }

        add(node) {
          this.map.set(node.key, node);
        }

        pop() {
          let m = Infinity;
          let node;
          this.map.forEach((n, k) => {
            if (n.pathD + n.heuristicD < m) {
              m = n.pathD + n.heuristicD;
              node = n;
            }
          });
          if (node) this.map.delete(node.key);
          return node;
        }

        has(node) {
          return this.map.has(node.key);
        }

        get(key) {
          return this.map.get(key);
        }

        delete(node) {
          this.map.delete(node.key);
        }
      }

      let columns = 45;
      let rows = 20;
      let nodeSize = 30; // node size
      let lineWidth = 1;
      let startX = 10;
      let startY = 10;

      let spaceExtWidth = 0;
      let spaceExtHeight = 0;
      let spaceOffsetX = 0;
      let spaceOffsetY = 0;

      const openSet = new NodeSet();
      const closeSet = new NodeSet();
      const obstacleSet = new NodeSet();

      let startNode;
      let destNode;
      let found = false;
      function searchPath() {
        draw();

        const astarBtn = document.getElementById("Astar");
        astarBtn.onclick = (e) => {
          if (found) {
            alert("请刷新页面重新开始，或清除路径");
            return;
          }
          found = astar();
          if (found) {
            let node = destNode.parent;
            while (node.parent) {
              drawNode(node);
              node = node.parent;
            }
          } else {
            alert("找不到路径，请清除障碍或重新设置起点终点再试！");
            openSet.clear();
            closeSet.clear();
            startNode.reset();
            destNode.reset();
          }
        };

        const clearBtn = document.getElementById("clearPath");
        clearBtn.onclick = (e) => {
          if (found) {
            let node = destNode.parent;
            while (node.parent) {
              clearNode(node);
              node = node.parent;
            }
            found = false;
            openSet.clear();
            closeSet.clear();
            startNode.reset();
            destNode.reset();
          }
        };
      }

      function astar() {
        startNode.parent = undefined;
        startNode.pathD = 0;
        startNode.heuristicD = heuristic(startNode, destNode);
        openSet.add(startNode);

        while (true) {
          // // console.log("openset:");
          // openSet.print();
          // // console.log("closeset:");
          // closeSet.print();
          let node = openSet.pop();
          if (!node) return false;
          closeSet.add(node);
          if (node.equal(destNode)) {
            destNode = node;
            return true;
          }
          node.neighborCoords().forEach((coord) => {
            const k = `${coord[0]},${coord[1]}`;
            // console.log("k:", k, columns, rows);
            let nb;
            if (
              coord[0] < 0 ||
              coord[0] >= columns ||
              coord[1] < 0 ||
              coord[1] >= rows
            ) {
              // console.log("1");
            } else if (!isOkToMove(node.x, node.y, coord[0], coord[1])) {
              // console.log("2");
            } else if ((nb = closeSet.get(k))) {
              // console.log("3");
            } else if ((nb = openSet.get(k))) {
              // console.log("4");
              const d = neighborDistance(node, nb);
              if (node.pathD + d < nb.pathD) {
                nb.parent = node;
                nb.pathD = node.pathD + d;
              }
            } else {
              // console.log("5");
              nb = new Node(coord[0], coord[1]);
              const d = neighborDistance(node, nb);
              nb.pathD = node.pathD + d;
              nb.heuristicD = heuristic(nb, destNode);
              nb.parent = node;
              openSet.add(nb);
            }
          });
        }
      }

      function isOkToMove(x1, y1, x2, y2) {
        const k = `${x2},${y2}`;
        if (obstacleSet.get(k)) return false;
        const d = Math.abs(x1 - x2) + Math.abs(y1 - y2);
        if (d == 1) return true;
        if (d > 2) return false;
        const k1 = `${x1},${y2}`;
        const k2 = `${x2},${y1}`;
        return !obstacleSet.get(k1) && !obstacleSet.get(k2);
      }

      // 对角线走位的距离，这个值大一点（不能大于2）可能会更走直线一点
      const diagonalMoveD = Math.sqrt(3);
      function heuristic(from, to) {
        const dx = Math.abs(from.x - to.x);
        const dy = Math.abs(from.y - to.y);
        return dx + dy - (2 - diagonalMoveD) * Math.min(dx, dy);
      }

      function neighborDistance(a, b) {
        const dx = Math.abs(a.x - b.x);
        const dy = Math.abs(a.y - b.y);
        const d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
        return d;
      }

      function drawNode(node) {
        const canvas = document.getElementById("map");
        const ctx = canvas.getContext("2d");
        const x = node.x * nodeSize + startX;
        const y = node.y * nodeSize + startY;
        ctx.fillStyle = "rgba(100, 0, 200, 0.5)";
        ctx.fillRect(
          x + lineWidth,
          y + lineWidth,
          nodeSize - 2 * lineWidth,
          nodeSize - 2 * lineWidth
        );
      }

      function clearNode(node) {
        const canvas = document.getElementById("map");
        const ctx = canvas.getContext("2d");
        const x = node.x * nodeSize + startX;
        const y = node.y * nodeSize + startY;
        ctx.clearRect(
          x + lineWidth,
          y + lineWidth,
          nodeSize - 2 * lineWidth,
          nodeSize - 2 * lineWidth
        );
      }

      function draw() {
        const canvas = document.getElementById("map");
        if (!canvas.getContext) {
          console.error("canvas not supported!");
        }

        const ctx = canvas.getContext("2d");
        ctx.lineWidth = lineWidth;

        function drawSpace(space) {
          const rooms = space.rooms;
          let minX = Infinity;
          let minY = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;

          rooms.forEach((room) => {
            minX = Math.min(minX, room.x);
            minY = Math.min(minY, room.y);
            maxX = Math.max(maxX, room.x + room.w);
            maxY = Math.max(maxY, room.y + room.h);
          });

          maxX += spaceExtWidth / 2;
          minX -= spaceExtWidth / 2;
          maxY += spaceExtHeight / 2;
          minY -= spaceExtHeight / 2;
          spaceOffsetX = startX - minX;
          spaceOffsetY = startY - minY;
          columns = (maxX - minX) / space.unit;
          rows = (maxY - minY) / space.unit;
          nodeSize = space.unit;

          drawGrid(ctx, startX, startY, columns, rows, nodeSize);

          rooms.forEach((room) => {
            room.items.forEach((item) => {
              if (
                item.kind === "horizontal wall" ||
                item.kind == "vertical wall"
              ) {
                const rows = item.h / space.unit;
                const columns = item.w / space.unit;
                const offsetR = (item.x - minX) / space.unit;
                const offsetC = (item.y - minY) / space.unit;
                for (let r = 0; r < rows; r++) {
                  for (let c = 0; c < columns; c++) {
                    setObstacleNode(offsetC + c, offsetR + r);
                  }
                }
              }
            });
          });
        }

        function drawGrid(ctx, x, y, columns, rows, nodeSize) {
          canvas.width = startX + nodeSize * columns + lineWidth;
          canvas.height = startY + nodeSize * rows + lineWidth;

          const maxX = x + columns * nodeSize;
          const maxY = y + rows * nodeSize;
          ctx.beginPath();
          for (let i = 0; i <= columns; i++) {
            ctx.moveTo(x + i * nodeSize, y);
            ctx.lineTo(x + i * nodeSize, maxY);
          }
          for (let i = 0; i <= rows; i++) {
            ctx.moveTo(x, y + i * nodeSize);
            ctx.lineTo(maxX, y + i * nodeSize);
          }
          ctx.stroke();
        }

        function clearRectAtPoint(x, y) {
          ctx.clearRect(
            x + lineWidth,
            y + lineWidth,
            nodeSize - 2 * lineWidth,
            nodeSize - 2 * lineWidth
          );
        }

        function fillRectAtPoint(x, y, fillStyle) {
          ctx.fillStyle = fillStyle;
          ctx.fillRect(
            x + lineWidth,
            y + lineWidth,
            nodeSize - 2 * lineWidth,
            nodeSize - 2 * lineWidth
          );
        }

        function setObstacleNode(column, row) {
          const x = column * nodeSize + startX;
          const y = row * nodeSize + startY;
          if (
            (startNode && startNode.isAt(column, row)) ||
            (destNode && destNode.isAt(column, row))
          ) {
            return;
          }

          const node = new Node(column, row);
          if (obstacleSet.has(node)) {
            clearRectAtPoint(x, y);
            obstacleSet.delete(node);
          } else {
            fillRectAtPoint(x, y, "rgba(0, 0, 200, 0.5)");
            obstacleSet.add(node);
          }
        }

        function click(e) {
          if (found) {
            alert("请刷新页面重新开始，或清除路径");
            return;
          }
          if (e.shiftKey) {
            shiftclick(e);
          } else {
            const column = Math.floor(
              (e.clientX + window.scrollX - startX) / nodeSize
            );
            const row = Math.floor(
              (e.clientY + window.scrollY - startY) / nodeSize
            );
            setObstacleNode(column, row);
          }
        }

        function shiftclick(e) {
          const column = Math.floor(
            (e.clientX + window.scrollX - startX) / nodeSize
          );
          const row = Math.floor(
            (e.clientY + window.scrollY - startY) / nodeSize
          );
          const x = column * nodeSize + startX;
          const y = row * nodeSize + startY;
          const node = new Node(column, row);
          if (!obstacleSet.has(node)) {
            if (startNode && startNode.isAt(column, row)) {
              clearRectAtPoint(x, y);
              startNode = undefined;
            } else if (destNode && destNode.isAt(column, row)) {
              clearRectAtPoint(x, y);
              destNode = undefined;
            } else if (!startNode) {
              startNode = new Node(column, row);
              fillRectAtPoint(x, y, "rgba(0, 200, 0, 0.5)");
            } else if (!destNode) {
              destNode = new Node(column, row);
              fillRectAtPoint(x, y, "rgba(200, 0, 0, 0.5)");
            }
          }
        }

        // drawGrid(ctx, startX, startY, columns, rows, nodeSize);
        canvas.addEventListener("click", click);

        fetch("./space.json")
          .then((resp) => resp.json())
          .then((json) => drawSpace(json));
      }
    </script>
  </head>
  <body onload="searchPath();">
    <canvas id="map" width="300" height="300"></canvas>
    <div style="margin: 10px">
      <button id="Astar">寻找路径</button>
      <button id="clearPath">清除路径</button>
      <p>
        单击空白格子设置障碍，已设置障碍为蓝色，单击蓝色障碍可清除障碍，shift+click设置起点（绿色）和终点（红色），shift+click起点和终点取消。
      </p>
    </div>
  </body>
</html>
